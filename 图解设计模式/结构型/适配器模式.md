#### 定义
适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。

#### 目的
将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

#### 使用场景
有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

#### 示例
```javascript
/*
 * @Author: zzh
 * @Date: 2021-11-17 09:43:48
 * @LastEditors: zzh
 * @LastEditTime: 2022-07-13 15:54:27
 * @FilePath: \origin\设计模式\结构型\adapter.js
 * @Description: 适配者模式
 * 注意事项：适配器模式本质上是一个亡羊补牢的模式， 就像一个转换器 
 * 它解决的是现存的两个接口之间不兼容的问题，不应该在软件的初期开发阶段就使用该模式；
 * 如果在设计之初就能够统筹的规划好接口的一致性，那么适配器就应该        尽量减少使用   。
 * 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
 * 主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
 */

// 老接口
const getOldCity = () => [ { name: 'nanjin', id: 1 }, { name: 'suzhou', id: 2 } ];

// 新接口希望是下面形式
// { hangzhou: 11, jinhua: 12 }

// 这时候就可采用适配者模式
const adaptor = (oldCity) => {
    let result = {}; 
    for (let city of oldCity) {
        result[city.name] = city.id;
    }

    return result;
} 


console.log(adaptor(getOldCity()));
```
输出：
> { nanjin: 1, suzhou: 2 }


#### 优点
1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。

#### 缺点
 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。